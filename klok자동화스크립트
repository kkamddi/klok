// 1. ëŒ€ìƒ ìš”ì†Œ ì„ íƒì (XPath + querySelector ê¸°ë°˜)
const CHAT_INPUT_XPATHS = [
  "/html/body/div[1]/div[2]/div[2]/div[2]/div[1]/form/div/textarea",
  "/html/body/div[1]/div[2]/div[2]/div[2]/div[2]/form/div/textarea"
];
const CHAT_INPUT_SELECTOR = "textarea[name='message']";
const SEND_BUTTON_XPATH = "/html/body/div[1]/div[2]/div[2]/div[2]/div[1]/form/div/button";
const SEND_BUTTON_SELECTOR = "button[type='submit']";

// 2. ì„¤ì •ê°’
const MESSAGES = [
  "New York is incredible!",
  "I've always wanted to visit Tokyo.",
  "Tell me something interesting!",
  "Amazing! What else should I know?",
  "Sounds cool! What's next?",
  "Barcelona is on my bucket list.",
  "Let's plan a trip to Sydney!",
  "Can you share more details?",
  "This is exciting! Tell me more.",
  "Wow! Any other recommendations?"
];
const DELAY_BETWEEN_CHARS = 50;
const DELAY_BEFORE_SEND = 500;
const MESSAGE_COUNT = 11;

// 3. XPath ê¸°ë°˜ ìš”ì†Œ ì°¾ê¸° í•¨ìˆ˜
function getElementByXPath(xpath) {
  return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
}

// 4. ì‚¬ìš© ê°€ëŠ¥í•œ ì…ë ¥ì°½ ì°¾ê¸°
function getAvailableChatInput() {
  for (let xpath of CHAT_INPUT_XPATHS) {
    let input = getElementByXPath(xpath);
    if (input) return input;
  }
  return document.querySelector(CHAT_INPUT_SELECTOR);
}

// 5. ì‚¬ìš© ê°€ëŠ¥í•œ ì „ì†¡ ë²„íŠ¼ ì°¾ê¸°
function getAvailableSendButton() {
  return getElementByXPath(SEND_BUTTON_XPATH) || document.querySelector(SEND_BUTTON_SELECTOR);
}

// 6. ì´ë²¤íŠ¸ ìƒì„± í•¨ìˆ˜
function createHumanLikeEvent(type, key, keyCode) {
  return new KeyboardEvent(type, {
    key: key,
    code: key,
    keyCode: keyCode,
    which: keyCode,
    bubbles: true,
    cancelable: true,
    composed: true
  });
}

// 7. ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
async function sendMessageLikeHuman(text) {
  const input = getAvailableChatInput();
  const sendBtn = getAvailableSendButton();
  
  if (!input) return console.error('âŒ ì…ë ¥ì°½ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  if (!sendBtn) return console.error('âŒ ì „ì†¡ ë²„íŠ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');

  input.focus();
  input.click();

  const nativeInputValueSetter = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(input), 
    'value'
  ).set;
  nativeInputValueSetter.call(input, text);
  input.dispatchEvent(new Event('input', { bubbles: true }));

  for (let i = 0; i < text.length; i++) {
    input.dispatchEvent(createHumanLikeEvent('keydown', text[i], text.charCodeAt(i)));
    input.dispatchEvent(createHumanLikeEvent('keypress', text[i], text.charCodeAt(i)));
    await new Promise(r => setTimeout(r, DELAY_BETWEEN_CHARS));
    input.dispatchEvent(createHumanLikeEvent('keyup', text[i], text.charCodeAt(i)));
  }

  await new Promise(r => setTimeout(r, DELAY_BEFORE_SEND));
  input.dispatchEvent(createHumanLikeEvent('keydown', 'Enter', 13));
  sendBtn.click();

  console.log(`âœ… [${new Date().toLocaleTimeString()}] ì „ì†¡ ì„±ê³µ: ${text}`);
}

// 8. 10ì´ˆ ê°„ê²© ì‹¤í–‰ ì‹œìŠ¤í…œ (11íšŒ ì‹¤í–‰ í›„ ì¤‘ì§€)
let messageIndex = 0;
let isSending = false;

const sendMessages = async () => {
  for (let i = 0; i < MESSAGE_COUNT; i++) {
    if (isSending) return;
    isSending = true;

    await sendMessageLikeHuman(MESSAGES[i % MESSAGES.length]);

    messageIndex++;
    isSending = false;

    if (i < MESSAGE_COUNT - 1) {
      await new Promise(r => setTimeout(r, 10 * 1000));
    }
  }

  console.log("ğŸš€ 11ë²ˆ ë©”ì‹œì§€ ì „ì†¡ ì™„ë£Œ! 24ì‹œê°„ í›„ ë‹¤ì‹œ ì‹¤í–‰í•©ë‹ˆë‹¤.");
  
  setTimeout(() => {
    messageIndex = 0;
    sendMessages();
  }, 24 * 60 * 60 * 1000); // í•˜ë£¨ í›„ ì¬ì‹¤í–‰
};

// ì‹¤í–‰ ì‹œì‘
sendMessages();
